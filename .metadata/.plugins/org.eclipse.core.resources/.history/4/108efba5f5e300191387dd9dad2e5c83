package logica;
import java.util.ArrayList;

public class Partida {

	private int tiempo;
	private int dificultad;
	private Felix pj;
	private Ralph boss;
	private Jugador player;
	private Edificio tablero;
	private ArrayList<Objeto> objetosPartida;
	
	public Partida(String nombre) {
		this.tiempo = 120;
		this.dificultad = 1;
		this.pj = new Felix();
		this.boss = new Ralph();
		this.player = new Jugador(nombre);
		this.tablero = new Edificio(this.dificultad);
		this.objetosPartida = new ArrayList<Objeto>();
	}
	
	
	public void ciclo(String dir, boolean martillazo) {
		
		if (this.tiempo != 0 && this.pj.getVidas() !=0 && this.dificultad < 11) { ///Ejecuta el ciclo si todavía hay tiempo, si Félix todavía tiene vidas y si no terminamos los diez niveles.
		
			//// BLOQUE DE ACCIONES
			Posicion posi = new Posicion (1, 1);
			System.out.print(this.tablero.getVentana(posi).salud[1].toString());
			System.out.print(this.tablero.getVentana(posi).salud[1].toString());

			System.out.print(this.tablero.getVentana(posi).salud[1].toString());

			System.out.print(this.tablero.getVentana(posi).salud[1].toString());

			System.out.print(this.tablero.getVentana(posi).salud[1].toString());

			System.out.print(this.tablero.getVentana(posi).salud[1].toString());

			
			
			
			/**Si Félix da un martillazo en este ciclo repara la ventana en la que se encuentra siempre y cuando
			 * ésta tenga al menos un panel roto. Si el nivel termina el jugador obtiene 500 puntos pr arreglar
			 * el panel, de lo contrario obtiene 100 puntos.**/
			if (!this.tablero.getVentanas()[this.pj.getPosFelix().getX()][this.pj.getPosFelix().getY()].arreglada()) { //Recupera la matriz de ventanas de la sección actual, y pregunta si el elemento en la ubicación de Félix necesita ser reparado.
				if (martillazo) {
					this.tablero.getVentanas()[this.pj.getPosFelix().getX()][this.pj.getPosFelix().getY()].reparar();
					if (this.tablero.nivelTerminado()) { //Si la ventana fue la última del nivel, la repara 
						this.player.setPuntaje(500);
					} else {
						this.player.setPuntaje(100);
						System.out.print("100 puntos!");
					}
				}
			}
			
			
			/**Recorre los objetos de la partida, si alguno está en la posición de Félix, de acuerdo a qué objeto es
			 * se realizan las acciones correspondientes. **/
			for(Objeto obj : this.objetosPartida) {
				if (obj.getPosicion().equals(pj.getPosFelix())) {	
					if (obj instanceof Torta) {  //Las tortas se eliminan una vez que Felix las recoge, y activan su invulnerabilidad
						this.pj.setInvulnerable();
						this.objetosPartida.remove(obj);
					} else {
						if (obj instanceof Pajaro) {  //Los pájaros reincial la etapa, no el nivel completo. se elimnan todos los objetos de la partida y se reinicia la posición de Félix al comienzo de la sección. Como la entrega no lo indica, Félix no pierde vidas.
							this.objetosPartida.removeAll(objetosPartida);
							this.tablero.reiniciarEtapa(dificultad);
							this.pj.reset();
						} else {
							if (obj instanceof Ladrillo) { //En el caso de los ladrillos se crea un nuevo tablero porque se reinicia el nivel, Félix pierde vida, vuelve a la posición inicial y  se eliminan todos los objetos de la partida.
								this.pj.perderVida();
								this.tablero = new Edificio(dificultad);
								this.objetosPartida.removeAll(objetosPartida);
								this.pj.reset();
							}
						}
					}
				}
				if (dificultad != 1) { ///Si la dificultad es mayor a 1 los ladrillos se saltean posiciones, por eso hay que comparar que la posición de Félix no esté entre la ubicación actual del ladrillo y lo que se desplazó en este ciclo.
					if (obj instanceof Ladrillo) {
						if (obj.getPosicion().getX() == this.pj.getPosFelix().getX()) {
							if((obj.getPosicion().getY() <= this.pj.getPosFelix().getY()) && (this.pj.getPosFelix().getY() <= (obj.getPosicion().getY()+dificultad))) {
								this.pj.perderVida();
								this.tablero = new Edificio(dificultad);
								this.objetosPartida.removeAll(objetosPartida);
							}
							}
					}
				}
			}
			
			
			////BLOQUE DE ACTUALIZACIONES
			
			
			/**Si el tablero decide generar un pájaro agrega un Objeto Pájaro a los elementos de la partida,
			 * instanciándolo con una altura aleatoria y una dirección (si comienza a la izquierda o derecha) aleatoria. **/
			if (tablero.generarPajaro()) {
				int y = (int) (Math.random()*2);
				double a = Math.random();
				int x = 0;
				if (a < 0.50) x = 4;
				Posicion posi = new Posicion(x, y);
				Objeto p = new Pajaro(posi);
				this.objetosPartida.add(p);
			}
			
			
			/**Si Ralph decide generar un ladrillo agrega un nuevo Objeto Ladrillo al vector de objetos de la partida, 
			 * instanciádolo con una posición aleatoria en x y siempre en la parte más alta de la sección. **/
			if (boss.generarLadrillo(dificultad)) {
				int x = (int) (Math.random()*4);
				Posicion posi = new Posicion(x, 2);
				Objeto l = new Ladrillo(posi);
				this.objetosPartida.add(l);
			}
			
			
			/**Actualiza todos los objetos del arreglo de Objetos de la partida, cada uno implementa 
			 * una actualización distinta. Además, si hay un Nicelander pregunta si hay que generar una torta. En tal caso
			 * crea un nuevo Objeto Torta en la posición del Nicelander. **/
			for (Objeto obj : this.objetosPartida) {
				obj.actualizar(dificultad);
				if (obj instanceof Nicelander) {
					Nicelander aux = (Nicelander)obj;
					if (aux.generarTorta()) {
						Objeto t = new Torta(aux.getPosicion());
						this.objetosPartida.add(t);
					}
				}
			}
			
			/** Este método se encarga del control de movimiento de Félix. De acuerdo a la dirección en que se deba mover Félix
			 * en este ciclo se hacen todas las comparaciones lógicas para saber si se puede mover en esa dirección. En caso de no haber
			 * obstáculos que lo impidan Félix se mueve, de lo contrario se queda en su lugar durante este ciclo. **/
			switch(dir) {
				case "Arriba": {
					if (this.pj.getPosFelix().getY()+1 < 3) {  //Evalúo si al moverme hacia arriba no voy a caer afuera del tablero. De ser así no me muevo.
						if (!this.tablero.getVentanas()[this.pj.getPosFelix().getX()][this.pj.getPosFelix().getY()+1].tieneMacetero()) { //Evalúo que la ventana de arriba no tenga macetero. Si lo tiene no me muevo.
							if (!this.tablero.getVentanas()[this.pj.getPosFelix().getX()][this.pj.getPosFelix().getY()].tieneMoldura()) { //Evalúo que la ventana en la que estoy parado no tenga moldura, si la tiene no me muevo.
								this.pj.actualizarFelix(dir); //En el caso de poder moverme hacia arriba lo hago.
							System.out.print("Se movió arriba!");
							}
						}
					}
				};
				case "Abajo": {
					if (this.pj.getPosFelix().getY()-1 >= 0) { //Las mismas evaluaciones que para arriba, pero para abajo.
						if (!this.tablero.getVentanas()[this.pj.getPosFelix().getX()][this.pj.getPosFelix().getY()-1].tieneMoldura()) {
							if (!this.tablero.getVentanas()[this.pj.getPosFelix().getX()][this.pj.getPosFelix().getY()].tieneMacetero()) {
								this.pj.actualizarFelix(dir);
								System.out.print("Se movió abajo!");

							}
						}
					}
				};
				case "Izquierda": {
					if (this.pj.getPosFelix().getX()-1 >= 0) { //Evalúo si al moverme hacia la izquierda no voy a caer afuera del tablero. De ser así no me muevo.
						if ((this.tablero.getVentanas()[this.pj.getPosFelix().getX()-1][this.pj.getPosFelix().getY()] instanceof VentanaConHojas)) { //Si la ventana de la izquierda es una ventana con hojas, tengo que preguntar si está abierta para moverme. Si es una ventana normal directamente me muevo.
							VentanaConHojas aux = (VentanaConHojas)this.tablero.getVentanas()[this.pj.getPosFelix().getX()-1][this.pj.getPosFelix().getY()]; 
							if (aux.estaAbierta()) {
								this.pj.actualizarFelix(dir);
								System.out.print("Se movió Izquierda!");

							}
						} else {
							this.pj.actualizarFelix(dir);
							System.out.print("Se movió Izquierda!");

						}
					}
				};
				case "Derecha": {
					if (this.pj.getPosFelix().getX()+1 < 5) { //Mismo caso que para la izquierda, pero para la derecha.
						if ((this.tablero.getVentanas()[this.pj.getPosFelix().getX()+1][this.pj.getPosFelix().getY()] instanceof VentanaConHojas)) {
							VentanaConHojas aux = (VentanaConHojas)this.tablero.getVentanas()[this.pj.getPosFelix().getX()+1][this.pj.getPosFelix().getY()]; 
							if (aux.estaAbierta()) {
								this.pj.actualizarFelix(dir);
								System.out.print("Se movió Derecha!");
							}
						} else {
							this.pj.actualizarFelix(dir);
							System.out.print("Se movió Derecha!");

						}
					}
				};
			}
			
			/**Pregunta a cada elemento si debe destruirlo. De ser así lo elimina del arreglo de objetos de la partida. 
			 * Cada Objeto sabe cuándo debe ser destruído. **/
			for (Objeto obj : this.objetosPartida) {
				if (obj.destruir()) this.objetosPartida.remove(obj);
			}
			
			
			/**Si se terminó el nivel se crea un nuevo tablero con mayor dificultad. Es importante
			 * verificar primero el nivel y luego la etapa porque si terminamos la última etapa el
			 * tablero va a intentar llevarnos a la etapa 4 del nivel, que no existe. **/
			if (this.tablero.nivelTerminado()) {
				this.dificultad++;
				this.tablero = new Edificio (dificultad);
				this.pj.reset();
				this.objetosPartida.removeAll(objetosPartida);
			}
			
			
			/** Si termina la sección avanzamos a la próxima etapa.**/
			if (this.tablero.seccionTerminada()) {
				this.tablero.proximaEtapa();
				this.pj.reset();
				this.objetosPartida.removeAll(objetosPartida);
			}
			
			
		
			this.tiempo--; //Decrementamos el tiempo para el próximo ciclo.
		
		} else { //Si el tiempo o las vidas de Félix llegan a cero se termina el juego. Si la dificultad (que a su vez es el nivel) es mayor que diez el jugador ganó el juego.
			if (this.dificultad <= 10) {
				System.out.print("Game over!");
			} else {
				System.out.print("Ganaste cruck!");
			}
			
		}
	}
	
	
	
	
}
