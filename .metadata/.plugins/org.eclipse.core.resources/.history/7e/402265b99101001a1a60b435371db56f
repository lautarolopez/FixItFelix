package logica;
import java.util.*;
public class Felix {
	
	private Posicion posFelix;
	private int vidas;
	private boolean invulnerable;
	private int timeLeftInv;
	
	public Felix() {
		this.posFelix = new Posicion(2, 0);
		this.vidas = 3;
		this.invulnerable = false;
		this.timeLeftInv = 0;
	}
	
	public void reset() { //Reinicia la posición y la invulnerabilidad se desactiva si está activada, pero no cambian las vidas.
		this.posFelix = new Posicion (2, 0);
		this.invulnerable = false;
		this.timeLeftInv = 0;
	}
	
	
	/**Recibe la sección actual de ventanas y busca en la que está parado actualmente. Si ésta no está totalmente sana
	 * repara un panel por cada martilazo, cuya cantidad recibe por parámtro. Además devuelve la cantidad de puntos que sumó con el 
	 * total de reparaciones. 
	 * @param etapa La matriz de ventanas de la sección actual
	 * @param martillazos La cantidad de martillazos que se deben dar en este ciclo
	 * @param ganeNivel un valor booleano para saber si después de reparar la ventana gané el nivel
	 * actual o no.
	 * @retun int Cantidad de puntos conseguidos reparando las ventanas**/
	public int repararVentana(ArrayList<ArrayList<Ventana>> etapa, int martillazos, boolean ganeNivel) {
		int puntaje = 0;
		while (martillazos != 0){
			if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()).arreglada()) { //Recupera la matriz de ventanas de la sección actual, y pregunta si el elemento en la ubicación de Félix necesita ser reparado.
					etapa.get(this.posFelix.getX()).get(this.posFelix.getY()).reparar();
					if (ganeNivel) { //Si la ventana fue la última del nivel, la repara 
						System.out.println("500 puntos!");
						puntaje += 500;
					} else {
						System.out.println("100 puntos!");
						puntaje += 100;
					}
			}
			martillazos--;
		}
		return puntaje;
	}
	

	public Posicion getPosFelix() {
		return posFelix;
	}

	public void actualizarFelix () {	//Actualiza el estado de invulnerabilidad.
		if (this.invulnerable) this.timeLeftInv--;
		if (this.timeLeftInv == 0) this.invulnerable = false;
	}
	
	public void setInvulnerable() {
		this.invulnerable = true;
		this.timeLeftInv = 2;
	}

	public void perderVida() {
		this.vidas--;
	}


	public int getVidas() {
		return vidas;
	}

	
	/**De acuerdo a la dirección que recibe evalúa si puede moverse hacia esa dirección, teniendo en cuenta los obstáculos,
	 * las ventanas abiertas y los límites del edificio. En el caso de encontrarse con alguna restricción simplemente
	 * no se mueve.
	 * @param dir Dirección en la que debe moverse Félix, con primera letra capital y sin punto
	 * @param etapa Matriz de ventanas de la sección actual. **/
	public boolean mover(String dir, ArrayList<ArrayList<Ventana>> etapa) {
		switch(dir) {
		case "Arriba":
			return movArriba(dir, etapa);
		case "Abajo": 
			return movAbajo(dir, etapa);
		case "Izquierda": 
			return movIzquierda(dir, etapa);
		case "Derecha": 
			if (this.posFelix.getX()+1 < 5) { //Evalúo si al moverme hacia la izquierda no voy a caer afuera del tablero. De ser así no me muevo.
				if (etapa.get(this.posFelix.getX()+1).get(this.posFelix.getY()).estaAbierta()) { //Si la ventana de la izquierda es una ventana con hojas, tengo que preguntar si está abierta para moverme. Si es una ventana normal directamente me muevo.
						this.posFelix.moverDer();;
						System.out.println("Se movió Derecha!");
				}
			}
		break;
		default : 
			System.out.println("Dirección inválida.");
		break;
		}
		System.out.println("Ahora Félix está en: " + this.posFelix.toString()); 
	}

	
	private boolean movArriba(String dir, ArrayList<ArrayList<Ventana>> etapa) {
		boolean seMovio= false;
		if (this.posFelix.getY()+1 < 3) {  //Evalúo si al moverme hacia arriba no voy a caer afuera del tablero. De ser así no me muevo.
			if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()+1).tieneMacetero()) { //Evalúo que la ventana de arriba no tenga macetero. Si lo tiene no me muevo.
				if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()).tieneMoldura()) { //Evalúo que la ventana en la que estoy parado no tenga moldura, si la tiene no me muevo.
					this.posFelix.moverAr();; //En el caso de poder moverme hacia arriba lo hago.
					System.out.println("Se movió arriba!");
					seMovio = true;
				}
			}
		}
		return seMovio;
	}
	
	private boolean movAbajo(String dir, ArrayList<ArrayList<Ventana>> etapa) {
		boolean seMovio = false;
		if (this.posFelix.getY()-1 >= 0) { //Las mismas evaluaciones que para arriba, pero para abajo.
			if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()-1).tieneMoldura()) {
				if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()).tieneMacetero()) {
					this.posFelix.moverAb();
					System.out.println("Se movió abajo!");
					seMovio = true;
				}
			}
		}
		return seMovio;
	}
	
	private boolean movIzquierda(String dir, ArrayList<ArrayList<Ventana>> etapa) {
		boolean seMovio = false;
		if (this.posFelix.getX()-1 >= 0) { //Evalúo si al moverme hacia la izquierda no voy a caer afuera del tablero. De ser así no me muevo.
			if (etapa.get(this.posFelix.getX()-1).get(this.posFelix.getY()).estaAbierta()) { //Si la ventana de la izquierda es una ventana con hojas, tengo que preguntar si está abierta para moverme. Si es una ventana normal directamente me muevo.
					this.posFelix.moverIzq();;
					System.out.println("Se movió Izquierda!");
			}
		}
		return seMovio;
	}
	
	private boolean movDerecha(String dir, ArrayList<ArrayList<Ventana>> etapa) {
		boolean seMovio = false;
		if (this.posFelix.getY()-1 >= 0) { //Las mismas evaluaciones que para arriba, pero para abajo.
			if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()-1).tieneMoldura()) {
				if (!etapa.get(this.posFelix.getX()).get(this.posFelix.getY()).tieneMacetero()) {
					this.posFelix.moverAb();
					System.out.println("Se movió abajo!");
					seMovio = true;
				}
			}
		}
		return seMovio;
	}
	
}
