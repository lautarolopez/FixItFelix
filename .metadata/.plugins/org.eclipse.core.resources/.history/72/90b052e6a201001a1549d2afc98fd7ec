package logica;
import java.util.*;
import grafica.GUI;
public class Partida{

	private int tiempo;
	private int dificultad;
	private Felix pj;
	private Ralph boss;
	private Jugador player;
	private Edificio tablero;
	private ArrayList<Objeto> objetosPartida;
	private GUI partidaGUI;
	
	public Partida(String nombre) {
		this.tiempo = 120;
		this.dificultad = 1;
		this.pj = new Felix();
		this.boss = new Ralph();
		this.player = new Jugador(nombre);
		this.tablero = new Edificio(this.dificultad);
		this.objetosPartida = new ArrayList<Objeto>();
		this.partidaGUI = new GUI();
	}
	
	
	
public boolean ciclo(String dir, int martillazos) {
		
		if (this.tiempo != 0 && this.pj.getVidas() !=0 && this.dificultad < 11) { ///Ejecuta el ciclo si todavía hay tiempo, si Félix todavía tiene vidas y si no terminamos los diez niveles.
		
			//// BLOQUE DE ACCIONES
			
			
			
			/**Suma puntos si Félix repara una ventana. (Set puntaje aumenta el puntaje, no lo setea.)**/
			this.player.setPuntaje(this.pj.repararVentana(this.tablero.getVentanas(), martillazos, this.tablero.nivelTerminado()));
			
			
			/**Método privado que analiza si hubo algún evento entre Félix y los objetos de la partida que afecte
			 *  el estado de la partida. **/
			this.gestionarColisiones();
			
			/**Si el tablero decide generar un pájaro (es aleatorio) agrega un Objeto Pájaro a los elementos de la partida.**/
			if (tablero.generarPajaro()) {
				Posicion posi = new Posicion(0, 0);
				Objeto p = new Pajaro(posi, this.tablero.getVentanas());
				this.objetosPartida.add(p);
				System.out.println("Se creó un pájaro en " + p.getPosicion().toString());
			}
			
			
			/**Si Ralph decide generar un ladrillo agrega un nuevo Objeto Ladrillo al vector de objetos de la partida. **/
			if (boss.generarLadrillo(dificultad)) {
				Posicion posi = new Posicion(0, 0);
				Objeto l = new Ladrillo(posi, this.tablero.getVentanas());
				this.objetosPartida.add(l);
				System.out.println("Se creó un ladrillo en " + l.getPosicion().toString());
			}
			///Con respecto a los ladrillos, la interpretación del enunciado fue que Ralph lanzaba ladrillos
			///de a uno por vez, aunque después jugando a la versión original vimos que lanza varios ladrillos
			///simultáneamente. En tal caso solo agregaríamos un for (0 a dificultad) para que haga esta acción
			///y se generen más ladrillos.
			
			
			
			////BLOQUE DE ACTUALIZACIONES
	
			/**Actualiza todos los objetos del arreglo de Objetos de la partida, cada uno implementa 
			 * una actualización distinta. Además consulta si debe generar alguna torta, solo los nicelanders
			 * responderán verdadero si corresponde, entonces crea una nueva instancia de Objeto Torta y la agrega
			 * a una lista auxiliar. Si se agregó efectivamente algún elemento a la lista auxiliar, ésta se agrega
			 * a la lista de objetos de la partida.**/
			ArrayList<Objeto> auxObj = new ArrayList<Objeto>();
			for (Objeto obj : this.objetosPartida) {
				obj.actualizar(dificultad, this.tablero.getVentanas());
				if (obj.generarTorta()) {
					Objeto t = new Torta(obj.getPosicion(), this.tablero.getVentanas());
					auxObj.add(t);
					System.out.println("Se creó una torta en " + t.getPosicion().toString());
				}
			}
			if (!(auxObj.isEmpty())) this.objetosPartida.addAll(auxObj);
			
			
			
			
			/**Mueve a Félix en la dirección que recibe en este turno. **/
			this.pj.mover(dir, this.tablero.getVentanas());
			
			switch(dir) {
				case "Arriba":
					this.partidaGUI.movArriba();
				break;
				case "Abajo":
					this.partidaGUI.movAbajo();
				break;
				case "Izquierda":
					this.partidaGUI.movIzquierda();
				break;
				case "Derecha":
					this.partidaGUI.movDerecha();
				break;
				default:
				break;
			}
			
			
			
			/** Consulta a todas las ventanas si debe generar un Nicelander. Cada ventana lo implementa a su manera. Si le retornan
			 * verdadero crea una nueva instancia de Objeto Nicelander y lo agrega a la lista de elementos de la partida.  **/
			for (ArrayList<Ventana> arrVent : this.tablero.getVentanas()) {
				for (Ventana vent : arrVent) {
					if (vent.generarNicelander()) {
						Objeto n = new Nicelander(vent.getPos(), this.tablero.getVentanas());
						this.objetosPartida.add(n);
						System.out.println("Se creó un Nicelander en " + n.getPosicion().toString());
					}
				}
			}
			
			
			
			/**Pregunta a cada elemento si debe destruirlo. De ser así lo elimina del arreglo de objetos de la partida. 
			 * Cada Objeto sabe cuándo debe ser destruído. **/
			Iterator<Objeto> iter = this.objetosPartida.iterator();
			while (iter.hasNext()) {
				Objeto obj = iter.next();
				if (obj.destruir()) {
					System.out.println("Se destruyó " + obj.toString() + " por terminar su ciclo de vida.");
					iter.remove();
				};
			}
			
						
			// Actualiza el tiempo de invulnerabilidad de Félix
			this.pj.actualizarFelix();
					
			
			/**Si se terminó el nivel se crea un nuevo tablero con mayor dificultad. Es importante
			 * verificar primero el nivel y luego la etapa porque si terminamos la última etapa el
			 * tablero va a intentar llevarnos a la etapa 4 del nivel, que no existe. **/
			if (this.tablero.nivelTerminado()) {
				this.dificultad++;
				this.tablero = new Edificio (dificultad);
				this.pj.reset();
				this.objetosPartida.removeAll(objetosPartida);
				System.out.println("Terminaste el nivel " + dificultad + ", felicidades!");
			}
			
			
			
			/** Si termina la sección avanzamos a la próxima etapa.**/
			if (this.tablero.seccionTerminada()) {
				this.tablero.proximaEtapa();
				this.pj.reset();
				this.objetosPartida.removeAll(objetosPartida);
				System.out.println("Siguiente etapa.");
			}
			
			
			////BLOQUE DE INFORMACIÓN DE ESTADO ////
			/** Este bloque brinda información del estado de la partida para verificar el correcto funcionamiento de todo el 
			 * ecosistema del juego en curso. **/
			this.tiempo--; //Decrementamos el tiempo para el próximo ciclo.
			System.out.println("Tiempo restante: " + tiempo);
			System.out.println("Vidas restantes: " + pj.getVidas());
			System.out.println("Nivel actual: " + dificultad);
			switch (this.tablero.getSeccionActual()) {
			case 0: {
				System.out.println("Sección actual: Suelo");
				break;
			}
			case 1:{
				System.out.println("Sección actual: Media");
				break;
			}
			case 2:{
				System.out.println("Sección actual: Más alta");
				break;
			}
			}
			System.out.println("-------------------------FIN DE CICLO-----------------------");
			return false;
		
		} else { //Si el tiempo o las vidas de Félix llegan a cero se termina el juego. Si la dificultad (que a su vez es el nivel) es mayor que diez el jugador ganó el juego.
			if (this.dificultad <= 10) {
				System.out.println("Game over!");
			} else {
				System.out.println("Ganaste cruck!");
			}
		return true;	
		}
		
	}
	
	
	
	
	
	
	/** Pregunta si Félix se encuentra con algún elemento de la lista, y de acuerdo al objeto realiza las acciones correspondientes.
	 * Pájaro: reinicia la sección sin perder vidas.
	 * Ladrillo: reinicia el nivel perdiendo una vida.
	 * Torta: Vuelve invulnerable a Félix durante una determinada cantidad de ciclos. **/
	private void gestionarColisiones() {
		if (this.tablero.getVentanas().get(this.pj.getPosFelix().getX()).get(this.pj.getPosFelix().getY()).pajaro()) {
			this.objetosPartida.removeAll(objetosPartida);
			this.tablero.reiniciarEtapa(dificultad);
			this.pj.reset();
			System.out.println("Chocó con un pájaro y se reinició la etapa.");
		} else {
			if (this.tablero.getVentanas().get(this.pj.getPosFelix().getX()).get(this.pj.getPosFelix().getY()).ladrillo()) {
				this.pj.perderVida();
				this.tablero = new Edificio(dificultad);
				this.objetosPartida.removeAll(objetosPartida);
				this.pj.reset();
				System.out.println("Chocó con un ladrillo y se reinicia el nivel.");
			} else {
				if (this.tablero.getVentanas().get(this.pj.getPosFelix().getX()).get(this.pj.getPosFelix().getY()).ladrillo()){
					this.pj.setInvulnerable();
					System.out.println("Félix ahora es invulnerable!");
				}
			}
		}
	}
	
	public Jugador getJugador() {
		return this.player;
	}
	
	
	
}
